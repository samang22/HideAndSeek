#pragma once
#include "CoreMinimal.h"
#include "Engine/EngineBaseTypes.h"
#include "NetDriver.generated.h"

class UNetConnection;

/*****************************************************************************************
 * 네트워크 드라이버(NetDrivers), 네트워크 연결(NetConnections) 및 채널(Channels)
 *****************************************************************************************
 *
 * UNetDrivers는 UNetConnections를 관리하고 그들 간에 공유될 수 있는 데이터를 관리합니다.
 * 일반적으로 주어진 게임에 대해 상대적으로 적은 수의 UNetDrivers가 존재합니다. 여기에는 다음이 포함될 수 있습니다:
 *  - 표준 게임 네트워크 트래픽을 담당하는 게임 네트 드라이버
 *  - 이전에 기록된 게임 데이터를 재생하거나 기록하는 데 사용되는 데모 네트 드라이버. 이는 리플레이가 작동하는 방식입니다.
 *  - "일반" 게임 플레이 트래픽 외의 네트워크 트래픽을 담당하는 비콘 네트 드라이버.
 *
 * 게임 또는 애플리케이션에 의해 사용자 지정 네트 드라이버를 구현하고 사용할 수도 있습니다.
 * NetConnections는 게임에 연결된 개별 클라이언트(또는 더 일반적으로 NetDriver에 연결된 클라이언트)를 나타냅니다.
 *
 * End point 데이터는 NetConnections에서 직접 처리되지 않습니다. 대신 NetConnections는 데이터를 채널로 라우팅합니다.
 * 각 NetConnection은 자체 채널 세트를 가집니다.
 *
 * 일반적인 채널 유형:
 *
 *  - 제어 채널(Control Channel)은 연결 상태(연결을 닫아야 하는지 여부 등)에 대한 정보를 보내는 데 사용됩니다.
 *  - 음성 채널(Voice Channel)은 클라이언트와 서버 간에 음성 데이터를 보내는 데 사용될 수 있습니다.
 *  - 고유한 액터 채널(Unique Actor Channel)은 서버에서 클라이언트로 복제된 각 액터에 대해 존재합니다.
 *
 * 사용자 지정 채널(Custom Channels)도 특정 용도로 생성 및 사용할 수 있습니다(그러나 이는 매우 일반적이지 않습니다).
 *
 *
 *****************************************************************************************
 * 게임 네트 드라이버, 네트 연결 및 채널
 *****************************************************************************************
 *
 *
 * 일반적인 상황에서는 "표준" 게임 트래픽 및 연결을 위한 단일 NetDriver(클라이언트 및 서버 모두에서 생성됨)만 존재합니다.
 *
 * 서버 NetDriver는 게임에 있는 각 플레이어를 나타내는 NetConnections 목록을 유지 관리합니다. 이는 액터 데이터를 복제하는 역할을 합니다.
 *
 * 클라이언트 NetDrivers는 서버에 대한 연결을 나타내는 단일 NetConnection을 가집니다.
 *
 * 서버와 클라이언트 모두에서 NetDriver는 네트워크에서 패킷을 수신하고 이를 적절한 NetConnection에 전달하며 필요할 때 새로운 NetConnections를 설정하는 역할을 합니다.
 *
 *
 *****************************************************************************************
 *****************************************************************************************
 *****************************************************************************************
 * 연결 시작 / 핸드셰이킹 흐름(Initiating Connections / Handshaking Flow)
 *****************************************************************************************
 *****************************************************************************************
 *****************************************************************************************
 *
 *
 * UIpNetDriver 및 UIpConnection(또는 파생 클래스)은 거의 모든 플랫폼에서 엔진 기본값이며, 아래의 모든 내용은 연결을 설정하고 관리하는 방법을 설명합니다.
 * 이러한 프로세스는 NetDriver의 구현에 따라 다를 수 있습니다.
 *
 * 서버와 클라이언트 모두 자체 NetDrivers를 가지며 모든 UE 복제 게임 트래픽은 IpNetDriver에 의해 전송되거나 수신됩니다.
 * 이 트래픽에는 연결 설정 및 문제가 발생했을 때 연결을 재설정하는 로직도 포함됩니다.
 *
 * 핸드셰이킹은 NetDriver, PendingNetGame, World, PacketHandlers 등 여러 장소에 걸쳐 분할됩니다.
 * 분할된 이유는 수신 연결이 "UE-프로토콜" 데이터를 전송하고 있는지 여부를 확인하거나, 주소가 악의적인지 여부를 판단하거나, 특정 클라이언트가 올바른 게임 버전을 가지고 있는지 여부를 확인하는 등의 다양한 요구가 있기 때문입니다.
 *
 *
 *****************************************************************************************
 * 시작 및 핸드셰이킹
 *****************************************************************************************
 *
 *
 * 서버가 맵을 로드할 때(UEngine::LoadMap을 통해) UWorld::Listen에 호출을 합니다.
 * 이 코드는 주요 게임 네트 드라이버를 생성하고 설정을 구문 분석하며 UNetDriver::InitListen을 호출하는 역할을 합니다.
 * 궁극적으로 이 코드는 클라이언트 연결을 청취하는 방법을 결정하는 역할을 합니다.
 * 예를 들어, IpNetDriver에서는 구성된 소켓 하위 시스템(ISocketSubsystem::GetLocalBindAddresses 및 ISocketSubsystem::BindNextPort 참조)을 통해 IP / 포트를 결정합니다.
 *
 * 서버가 청취를 시작하면 클라이언트 연결을 수락할 준비가 됩니다.
 *
 * 클라이언트가 서버에 참가하려고 하면, 먼저 UEngine::Browse에서 서버의 IP를 사용하여 새 UPendingNetGame을 설정합니다.
 * UPendingNetGame::Initialize 및 UPendingNetGame::InitNetDriver는 각각 설정 초기화 및 NetDriver 설정을 담당합니다.
 * 클라이언트는 이 초기화의 일환으로 서버에 대한 UNetConnection을 즉시 설정하고 해당 연결에서 서버로 데이터를 전송하여 핸드셰이킹 프로세스를 시작합니다.
 *
 * 클라이언트와 서버 모두에서 UNetDriver::TickDispatch는 일반적으로 네트워크 데이터를 수신하는 역할을 합니다.
 * 일반적으로 패킷을 수신할 때 해당 주소를 검사하여 이미 알고 있는 연결에서 온 것인지 확인합니다.
 * 소스 주소에 대해 연결을 설정했는지 여부를 단순히 FInternetAddr에서 UNetConnection으로의 맵을 유지하여 결정합니다.
 *
 * 패킷이 이미 설정된 연결에서 온 경우, 해당 패킷을 UNetConnection::ReceivedRawPacket을 통해 연결로 전달합니다.
 * 패킷이 이미 설정된 연결에서 온 것이 아닌 경우, 이를 "비연결"(connectionless)로 처리하고 핸드셰이킹 프로세스를 시작합니다.
 *
 * 이 핸드셰이킹이 작동하는 방법에 대한 자세한 내용은 StatelessConnectionHandlerComponent.cpp를 참조하십시오.
 *
 *
 *****************************************************************************************
 * UWorld / UPendingNetGame / AGameModeBase 시작 및 핸드셰이킹
 *****************************************************************************************
 *
 *
 * 클라이언트와 서버에서 UNetDriver 및 UNetConnection이 핸드셰이킹 프로세스를 완료한 후, 클라이언트에서 UPendingNetGame::SendInitialJoin이 호출되어 게임 수준 핸드셰이킹을 시작합니다.
 *
 * 게임 수준 핸드셰이킹은 보다 구조적이고 복잡한 FNetControlMessages 세트를 통해 수행됩니다.
 * 전체 제어 메시지 세트는 DataChannel.h에서 찾을 수 있습니다.
 *
 * 이러한 제어 메시지를 처리하는 대부분의 작업은 UWorld::NotifyControlMessage 및 UPendingNetGame::NotifyControlMessage에서 수행됩니다. 간략히 설명하면 흐름은 다음과 같습니다:
 *
 * 클라이언트의 UPendingNetGame::SendInitialJoin이 NMT_Hello를 보냅니다.
 *
 * 서버의 UWorld::NotifyControlMessage가 NMT_Hello를 수신하고 NMT_Challenge를 보냅니다.
 *
 * 클라이언트의 UPendingNetGame::NotifyControlMessage가 NMT_Challenge를 수신하고 NMT_Login에 데이터를 다시 보냅니다.
 *
 * 서버의 UWorld::NotifyControlMessage가 NMT_Login을 수신하고 도전 데이터를 검증한 후 AGameModeBase::PreLogin을 호출합니다.
 * PreLogin에서 오류가 보고되지 않으면 서버는 UWorld::WelcomePlayer를 호출하여 AGameModeBase::GameWelcomePlayer를 호출하고 맵 정보를 포함한 NMT_Welcome을 보냅니다.
 *
 * 클라이언트의 UPendingNetGame::NotifyControlMessage가 NMT_Welcome을 수신하고 맵 정보를 읽어(나중에 로드할 수 있도록) NMT_NetSpeed 메시지를 클라이언트의 설정된 네트 속도로 보냅니다.
 *
 * 서버의 UWorld::NotifyControlMessage가 NMT_NetSpeed를 수신하고 연결의 네트 속도를 적절히 조정합니다.
 *
 * 이 시점에서 핸드셰이킹이 완료된 것으로 간주되며 플레이어는 게임에 완전히 연결됩니다.
 * 맵을 로드하는 데 걸리는 시간에 따라 클라이언트는 UWorld로 제어가 전환되기 전에 UPendingNetGame에서 비핸드셰이킹 제어 메시지를 여전히 수신할 수 있습니다.
 *
 * 암호화가 필요한 경우 추가 단계도 있습니다.
 *
 *
 *****************************************************************************************
 * 손실된 연결 재설정
 *****************************************************************************************
 *
 *
 * 게임 진행 중 여러 가지 이유로 연결이 끊어질 수 있습니다.
 * 인터넷이 끊어지거나 사용자가 LTE에서 WIFI로 전환하거나 게임을 떠날 수 있습니다.
 *
 * 서버에서 이러한 끊김을 시작했거나 그렇지 않으면 이를 인지한 경우(타임아웃 또는 오류로 인해),
 * UNetConnection을 닫고 게임에 알림으로써 끊김을 처리합니다.
 * 그 시점에서 게임이 진행 중 참가(Join In Progress) 또는 재참가를 지원하는지 여부를 결정하는 것은 게임의 몫입니다.
 * 게임이 이를 지원하는 경우 위의 핸드셰이킹 흐름을 완전히 다시 시작합니다.
 *
 * 클라이언트의 연결이 잠시 중단되었으나 서버가 이를 인지하지 못한 경우,
 * 엔진/게임은 일반적으로 자동으로 복구됩니다(다소의 패킷 손실 / 지연 스파이크가 발생할 수 있음).
 *
 * 그러나 클라이언트의 IP 주소나 포트가 어떤 이유로든 변경되고 서버가 이를 인지하지 못한 경우,
 * 저수준 핸드셰이킹을 다시 수행하여 복구 프로세스를 시작합니다. 이 경우 게임 코드는 알림을 받지 않습니다.
 *
 * 이 프로세스는 StatlessConnectionHandlerComponent.cpp에 설명되어 있습니다.
 *
 *
 *****************************************************************************************
 *****************************************************************************************
 *****************************************************************************************
 * 데이터 전송
 *****************************************************************************************
 *****************************************************************************************
 *****************************************************************************************
 *
 *
 * 게임 NetConnections 및 NetDrivers는 일반적으로 사용되는 기본 통신 방법/기술에 대해 무관심합니다.
 * 이는 하위 클래스(UIpConnection / UIpNetDriver 또는 UWebSocketConnection / UWebSocketNetDriver와 같은 클래스)에 맡겨집니다.
 *
 * 대신 UNetDriver 및 UNetConnection은 패킷(Packets) 및 번치(Bunches)를 사용합니다.
 *
 * 패킷은 호스트와 클라이언트의 NetConnections 쌍 사이에 전송되는 데이터 블롭입니다.
 * 패킷은 패킷에 대한 메타 데이터(헤더 정보 및 확인 정보 등)와 번치로 구성됩니다.
 *
 * 번치는 호스트와 클라이언트의 채널 쌍 사이에 전송되는 데이터 블롭입니다.
 * 연결이 패킷을 수신하면 해당 패킷을 개별 번치로 분해합니다.
 * 그런 다음 이러한 번치는 개별 채널로 전달되어 추가로 처리됩니다.
 *
 * 패킷에는 번치가 없을 수도 있고, 단일 번치가 있을 수도 있으며, 여러 번치가 있을 수도 있습니다.
 * 번치의 크기 제한이 단일 패킷의 크기 제한보다 클 수 있기 때문에 UE는 부분 번치의 개념을 지원합니다.
 *
 * 번치가 너무 큰 경우 전송 전에 여러 개의 작은 번치로 나눕니다.
 * 이러한 번치는 PartialInitial, Partial 또는 PartialFinal로 플래그가 지정됩니다. 이 정보를 사용하여 수신 측에서 번치를 다시 조립할 수 있습니다.
 *
 *  예: 클라이언트에서 서버로의 RPC 호출.
 *    - 클라이언트가 Server_RPC를 호출합니다.
 *    - 해당 요청은(NetDriver 및 NetConnection을 통해) RPC가 호출된 액터를 소유하는 액터 채널로 전달됩니다.
 *    - 액터 채널은 RPC 식별자 및 매개 변수를 번치로 직렬화합니다. 번치에는 액터 채널의 ID도 포함됩니다.
 *    - 액터 채널은 번치를 보내도록 NetConnection에 요청합니다.
 *    - 나중에 NetConnection은 이를 포함한 데이터를 패킷으로 조립하여 서버로 보냅니다.
 *    - 서버에서 패킷은 NetDriver에 의해 수신됩니다.
 *    - NetDriver는 패킷을 보낸 주소를 검사하고 해당 패킷을 적절한 NetConnection에 전달합니다.
 *    - NetConnection은 패킷을 개별 번치로 분해합니다(하나씩).
 *    - NetConnection은 번치의 채널 ID를 사용하여 번치를 해당 액터 채널에 라우팅합니다.
 *    - 액터 채널은 번치를 분해하고, RPC 데이터를 포함하고 있음을 확인한 후 RPC ID 및 직렬화된 매개 변수를 사용하여 액터에서 적절한 함수를 호출합니다.
 *
 *
 *****************************************************************************************
 * 신뢰성 및 재전송
 *****************************************************************************************
 *
 *
 * UE 네트워킹은 일반적으로 기본 네트워크 프로토콜에 의해 신뢰성이 보장되지 않는다고 가정합니다.
 * 대신 자체 패킷 및 번치의 신뢰성 및 재전송을 구현합니다.
 *
 * NetConnection이 설정되면 패킷 및 번치의 시퀀스 번호를 설정합니다.
 * 이들은 고정되거나 무작위화될 수 있습니다(무작위화된 경우 시퀀스는 서버에서 전송됩니다).
 *
 * 패킷 번호는 NetConnection마다 다르며, 전송되는 모든 패킷에 대해 증가합니다. 모든 패킷에는 패킷 번호가 포함되며,
 * 동일한 패킷 번호로 패킷을 재전송하지 않습니다.
 *
 * 번치 번호는 채널마다 다르며, 전송되는 모든 **신뢰할 수 있는** 번치에 대해 증가합니다. 모든 **신뢰할 수 있는** 번치에는
 * 번치 번호가 포함됩니다. 그러나 패킷과 달리 정확한(신뢰할 수 있는) 번치는 재전송될 수 있습니다. 이는 동일한 번치 번호로
 * 번치를 다시 보낼 수 있음을 의미합니다.
 *
 * 코드 전체에서 위에서 설명한 번치 번호와 패킷 번호는 일반적으로 시퀀스 번호로만 지칭됩니다. 여기에서는 명확한 이해를 위해 구분합니다.
 *
 *  --- 수신된 누락된 패킷 감지 ---
 *
 *
 *  패킷 번호를 할당함으로써 수신된 패킷이 손실되었는지 쉽게 감지할 수 있습니다.
 *  이는 마지막으로 성공적으로 수신된 패킷 번호와 현재 처리 중인 패킷의 패킷 번호 간의 차이를 계산하는 것으로 수행됩니다.
 *
 *  좋은 조건에서는 모든 패킷이 전송된 순서대로 수신됩니다. 이는 차이가 +1임을 의미합니다.
 *
 *  차이가 1보다 큰 경우 이는 일부 패킷을 놓쳤음을 나타냅니다. 누락된 패킷이 드롭된 것으로 가정하고,
 *  현재 패킷이 성공적으로 수신된 것으로 간주하며, 앞으로 해당 번호를 사용합니다.
 *
 *  차이가 음수(또는 0)인 경우 이는 패킷이 순서대로 수신되지 않았거나 외부 서비스가 데이터를 다시 전송하려고 함을 나타냅니다.
 *  (엔진은 시퀀스 번호를 재사용하지 않음을 기억하십시오).
 *
 *  두 경우 모두 엔진은 누락되거나 유효하지 않은 패킷을 무시하고 ACK를 보내지 않습니다.
 *
 *  동일한 프레임에서 수신된 순서가 잘못된 패킷을 "수정"하는 방법도 있습니다.
 *  활성화된 경우 누락된 패킷을 감지하면(차이 > 1), 현재 패킷을 즉시 처리하지 않습니다.
 *  대신 이를 큐에 추가합니다. 다음에 패킷을 성공적으로 수신하면(차이 == 1), 큐의 헤드가 올바르게 정렬된 상태인지 확인합니다.
 *  그렇다면 처리하고, 그렇지 않으면 계속해서 패킷을 수신합니다.
 *
 *  현재 사용할 수 있는 모든 패킷을 읽은 후, 이 큐를 플러시하여 남아 있는 패킷을 처리합니다.
 *  이 시점에서 누락된 모든 항목은 드롭된 것으로 간주됩니다.
 *
 *  성공적으로 수신된 모든 패킷은 ACK로 보낸 사람에게 패킷 번호가 전송됩니다.
 *
 *
 *  --- 송신된 누락된 패킷 감지 ---
 *
 *
 *  앞서 언급한 바와 같이, 패킷이 성공적으로 수신될 때마다 수신자는 ACK를 보냅니다.
 *  이 ACK에는 시퀀스 순서로 성공적으로 수신된 패킷 번호가 포함됩니다.
 *
 *  수신자가 패킷 번호를 추적하는 것과 유사하게, 송신자는 가장 높은 ACK된 패킷 번호를 추적합니다.
 *
 *  ACK가 처리되는 동안, 마지막으로 수신된 ACK 아래의 모든 ACK는 무시되고 패킷 번호의 모든 간격은 확인되지 않은 것으로 간주됩니다(NAKed).
 *
 *  이러한 ACK 및 NAK를 처리하고 누락된 데이터를 재전송하는 것은 송신자의 책임입니다.
 *  새로운 데이터는 새로운 송신 패킷에 추가됩니다(다시 말하지만, 이미 전송된 패킷을 다시 보내거나 시퀀스 번호를 재사용하지 않습니다).
 *
 *
 *  --- 누락된 데이터 재전송 ---
 *
 *
 * 앞서 언급한 바와 같이, 패킷 자체에는 유용한 게임 데이터가 포함되어 있지 않습니다. 대신 이를 구성하는 번치가 의미 있는 데이터를 가지고 있습니다.
 *
 * 번치는 신뢰할 수 있거나 신뢰할 수 없는 것으로 표시될 수 있습니다.
 *
 * 엔진은 신뢰할 수 없는 번치가 드롭된 경우 이를 재전송하려고 하지 않습니다. 따라서 번치가 신뢰할 수 없는 것으로 표시된 경우,
 * 게임/엔진은 이를 계속할 수 있어야 하거나 외부 재시도 메커니즘을 구현해야 하며, 또는 데이터가 중복 전송되어야 합니다.
 * 따라서 아래의 모든 내용은 신뢰할 수 있는 번치에만 적용됩니다.
 *
 * 그러나 엔진은 신뢰할 수 있는 번치를 재전송하려고 합니다. 신뢰할 수 있는 번치가 전송될 때마다 이는 확인되지 않은 신뢰할 수 있는 번치 목록에 추가됩니다.
 * 번치를 포함한 패킷에 대해 NAK를 수신하면 엔진은 해당 번치의 정확한 사본을 재전송합니다.
 * 번치가 부분적일 수 있기 때문에 단일 부분 번치라도 드롭되면 전체 번치가 재전송됩니다.
 * 번치를 포함하는 모든 패킷이 ACK되면 이를 목록에서 제거합니다.
 *
 * 패킷과 유사하게, 수신된 신뢰할 수 있는 번치의 번치 번호를 마지막으로 성공적으로 수신된 번치와 비교합니다.
 * 차이가 음수인 경우 번치를 단순히 무시합니다. 차이가 1보다 크면 번치를 놓쳤다고 가정합니다.
 * 패킷 처리와 달리 이 데이터를 폐기하지 않습니다. 대신 번치를 대기열에 추가하고 **모든** 번치, 신뢰할 수 있는 번치 또는 신뢰할 수 없는 번치의 처리를 일시 중지합니다.
 * 누락된 번치를 수신했다고 감지할 때까지 처리가 재개되지 않습니다.
 * 이 시점에서 이를 처리한 다음 대기열에 있는 번치의 처리를 시작합니다.
 * 누락된 번치를 기다리는 동안 수신된 새 번치 또는 여전히 대기열에 번치가 있는 동안 수신된 새 번치는 즉시 처리되지 않고 대기열에 추가됩니다.
 *
 */


UCLASS()
class ENGINE_API UNetDriver : public UObject
{
    GENERATED_BODY()

public:
    UNetDriver();
    virtual ~UNetDriver();

    virtual void Tick(float DeltaSeconds) {}

    bool IsServer() const { return bServer; }

public:
    void SetNetConnectionClass(TSubclassOf<UNetConnection> InClass);

    /**
     * 서버 모드에서 네트워크 드라이버를 초기화합니다 (리스너)
     *
     * @param InNotify 네트 드라이버와 연관된 알림 객체
     * @param ListenURL 이 리스너의 연결 URL
     * @param bReuseAddressAndPort 동일한 주소/포트에 여러 소켓을 바인딩할 수 있는지 여부
     * @param Error 생성된 오류 메시지가 저장될 out 매개변수
     *
     * @return 성공하면 true, 그렇지 않으면 false (오류 메시지는 Error 매개변수 확인)
     */
    virtual bool InitListen(class FNetworkNotify* InNotify, FURL& ListenURL, bool bReuseAddressAndPort, FString& Error)
    {
        bServer = true;
        return InitBase(!bServer, InNotify, ListenURL, bReuseAddressAndPort, Error);
    }

    /**
    * 클라이언트 모드에서 NetDriver를 초기화합니다.
    *
    * @param InNotify NetDriver와 연결할 알림 객체
    * @param ConnectURL 연결할 호스트의 원격 ip:port
    * @param Error 연결 시도 중 발생한 결과 오류 문자열
    *
    * @return 성공하면 true, 그렇지 않으면 false (Error 매개변수 확인)
    */
    virtual bool InitConnect(class FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error)
    {
        bServer = false;
        return InitBase(!bServer, InNotify, ConnectURL, false, Error);
    }

    // 해당 Connection을 수동으로 끊습니다
    virtual void CloseConnection(UNetConnection* Connection) {}

protected:
    /**
     * 서버와 클라이언트 연결 설정 간의 공통 초기화
     *
     * @param bInitAsClient 클라이언트로 초기화할지 서버로 초기화할지 여부
     * @param InNotify 네트 드라이버와 연관된 알림 객체
     * @param URL 목적지 URL
     * @param bReuseAddressAndPort 동일한 주소/포트에 여러 소켓을 바인딩할 수 있는지 여부
     * @param Error 실패 시 오류 문자열을 포함하는 출력 매개변수
     *
     * @return 성공하면 true, 그렇지 않으면 false (오류 메시지는 Error 매개변수 확인)
     */
    virtual bool InitBase(bool bInitAsClient, class FNetworkNotify* InNotify, const FURL& InURL, bool bReuseAddressAndPort, FString& Error);

    /**
    * 새로운 연결에 사용할 NetConnection 클래스를 초기화합니다.
    */
    virtual bool InitConnectionClass();

public:
    /** 사용할 NetConnection Class */
    TSubclassOf<UNetConnection> NetConnectionClass;

    /**
     * 네트워크 상태를 다른 객체(예: World, FNetworkNotify를 구현하는 다른 객체)에 전달하기 위한 인터페이스
     */
    class FNetworkNotify* Notify;
    FURL URL;
    bool bServer = false;
};